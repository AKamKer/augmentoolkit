#### **I. High-Level Summary**

The primary goal was to solve **entity ambiguity**, where the LLM would generate characters with the same name but different personalities and backstories (e.g., "Garnet the Captain" and "Garnet the Gladiator"). This was resolved by creating a "Character Bible" system that establishes a canonical identity for each character, ensuring that once a character is created, their core traits remain consistent across all future stories they appear in.

The final system is **robust**, **configurable**, and **portable**.

#### **II. Core Feature: The Character Bible System**

*   **`character_bible.json`:** A new file is now created in the output directory. It acts as a persistent, structured database (JSON) of all unique characters generated by the pipeline.
*   **Concurrency Safety:** The system is designed to work in a highly concurrent `asyncio` environment. It uses a combination of an `asyncio.Lock` and direct file I/O within the lock to ensure that multiple tasks can safely read from and write to the character bible without creating race conditions.
*   **Optional & Configurable:** The entire feature can be enabled or disabled via a single boolean flag in the project's `.yaml` configuration file.

    *   **`use_character_bible: true`**: Enforces strict character consistency using the bible.
    *   **`use_character_bible: false`**: Bypasses the system entirely, allowing the LLM to generate unique, one-off characters for every story.

#### **III. Detailed Changes by File**

##### **`rptoolkit_helpers.py`)**

This file received the most new code, containing all the core logic for the new system.

1.  **`manage_character_consistency_from_file()`:**
    *   This is the central function for the new system.
    *   It's called for every generated character and uses an `asyncio.Lock` for safety.
    *   It reads `character_bible.json`, checks if a character's **base name** exists, and enforces consistency.
    *   It writes the updated bible back to disk on every check, ensuring the state is always synchronized.

2.  **Name Normalization (`get_base_name()`):**
    *   A powerful new helper was created to derive a "base name" from a full name.
    *   It intelligently strips both **prefix titles** (e.g., "Queen," "Captain," "Prince") and **suffix epithets** (e.g., "the Mad," ", the Crimson Fury").
    *   This ensures that "Queen Scarlet," "Scarlet," and "Scarlet the Terrible" are all correctly identified as the same base character, "Scarlet," for lookups.

3.  **Structured Scene Card Handling:**
    *   **`parse_scene_card_to_dict()`:** A robust parser was developed to convert the raw text of a `scene_card` into a structured Python dictionary. It was specifically hardened to handle common LLM formatting errors, such as missing delimiters (`-- END CHARACTER INFO --`) and variations in headings.
    *   **`reconstruct_scene_card_from_dict()`:** Rebuilds the `scene_card` text from a dictionary. This was crucial for the consistency logic, allowing us to merge the *canonical character data* with a *newly generated scene introduction*.

4.  **Critical Bug Fixes & Hardening:**
    *   **`extract_charname()`:** This function was completely overhauled to be more robust. It now correctly handles names on new lines and, most importantly, has safeguards to **prevent it from ever parsing the `{user}` block as a character name**, which was a major source of bible pollution.
    *   **`write_final_dataset_files()`:** A `KeyError` was fixed by changing a direct dictionary access (`story["charname"]`) to a safe one (`story.get("charname")`), making the final file writing step resilient to incomplete data objects.

##### **`rptoolkit.py`**

This file was modified to integrate and control the new system.

1.  **`rptoolkit_pipeline()` (Main Function):**
    *   Now accepts the new `use_character_bible` parameter from the YAML config.
    *   Contains a new `if use_character_bible:` block that conditionally prepares the `bible_path` and `bible_lock`.
    *   Passes the `use_character_bible` flag and related variables down to the `rptoolkit_executor` so every worker task is aware of the setting.

2.  **`generate_data()` (Worker Function):**
    *   This function's signature was updated to accept the new configuration flags.
    *   It now contains a top-level `if use_character_bible:` gate. If `true`, it calls `manage_character_consistency_from_file`. If `false`, it completely bypasses all consistency logic, providing the optional functionality.
    *   Extensive debugging (`try...finally`) and safety checks were added to ensure that if any step in the generation chain fails (e.g., rating), the entire task exits gracefully and returns `None`, preventing crashes.

##### **`depth_first_pipeline_step_class.py` (The Framework)**

*   A fundamental bug in the `create_depth_first_executor` was fixed. The `executor` function was missing a `return` statement, causing it to always return `None` even after successfully completing all tasks. We fixed this by adding **`return input_dict`** at the end, which was a key breakthrough that allowed the entire pipeline to finally run to completion.
